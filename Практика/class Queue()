#include <iostream>
#include <stdio.h>
#define size 5
using namespace std;

class Queue {
    int buffer[size];
    int start  = -1, end = -1;
public:
// конструктор копирования
// оператор копирующего присваивания
	Queue() = default;
	~Queue() {
		delete [] buffer;
	}
	
	bool IsEmpty() const {
		return (start == end && end == -1);
	}

	bool IsFull() {
		return ((end + 1) % size == start);
	}
	
	int counter() const {
		if (IsEmpty()) 
			return 0;
		return (end >= start) ? (end - start + 1) : (size - (start - end - 1));
	}

	int front() const {
		if (IsEmpty())
			exit(1);
		return buffer[start];
	}

	int back() const {
		if (IsEmpty())
			exit(1);
		return buffer[end];
	}

	void reset() {
		 start = end = -1;
	}

	bool push(int element) {
		if (IsEmpty()) 
			start = end = 0;
		else {
			if (IsFull()) {
				int * new_buffer = new buffer[size * 2];
				int i = start, j = 0;
				while (i != end) {
					new_buffer[j++] = buffer[i];
					i = (i + 1) % size;					
				}
				new_buffer[j] = buffer[i];
				start = 0;
				end = j;
				size *= 2;
				delete [] buffer;
				buffer = new_buffer;
			}			
			end = (end + 1) % size;
		}
		buffer[end] = element;
		return true;		
	}

	bool pop() {
		if (IsEmpty())
			return false;
		if (start == end) 
			reset();
		else 
			start = (start + 1) % size;
		return true;		
	}

	void print() const {
		if (IsEmpty())
			cout << "The queue is empty \n";
		else {
			if (start == end) 
				cout << buffer[start] << endl;
			else {
				int i = start;
				while (i != end) {
					cout << buffer[i] << "->";
					i = (i + 1) % size;
				}
				cout << buffer[i] << endl;
			}
		}
	}
};

int main() {
	return 0;
}
